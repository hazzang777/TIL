# 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?

## 역사의 흐름은 무엇인가?

가장 큰변화는 `자바 8` 에서 일어남

자바 9에서도 중요한 변화가 있었다. 자바 8만큼 획기전인 것이 아니다.

자바 10에서는 형 추론과 관련해 약간의 변화만 일어남.

→ 크고 작은 변화 덕분에 프로그램을 더 쉽게 구현할 수 있게 됨

자바 8 이전에 CPU의 나머지 코어를 활용할려면 스레드를 사용했는데

→ 이것은 관리하기 힘들고 불편했다.

자바는 이러한 병렬 실행 환경을 쉽게 관리하고 에러가 덜 발생하는 방향으로 진화하려 노력

자바 1.0: 쓰레드와 락, 심지어 메모리 모델까지 지원

자바 5: 스레드 풀, 병렬 실행 컬렉션

자바 7: 포크/조인 프레임워크를 제공

자바 8에서는 병렬 실행을 새롭고 단순한 방식으로 접근할 수 있는 방법을 제공

`자바 8` 의 특징 3가지

1. 스트림 API
2. 메서드에 코드를 전달하는 기법
    1. 새롭고 간결한 방식으로 동작 파라미터화를 구현할 수 있음
    2. 함수형 프로그래밍에서 위력을 발휘
3. 인터페이스와 디폴트 메서드

## 왜 아직도 자바는 변화하는가?

- 예전 자바로는 병렬 프로세싱을 활용해야 하는 데 자바 8이전에는 충분히 대응할 수 없었음

```

새로운 프로그래밍이 등장하는 것처럼 기후가 변하고 식물에 영향을 미치면서 
기존 식물을 대신해서 새로운 식물을 길러야 하는것 처럼
새로운 프로젝트에는 다른 언어를 선택해야 한다. 
```

→ 새로운 언어는 변화하는 환경에 빠르게 적응하면서 점점 대중화된다는 것.

`자바 8` 은 다양한 프로그래밍 도구 그리고 다양한 프로그래밍 문제를 더 빠르고 정확하며 쉽게 유지보수할 수 있다는 장점을 제공

### 스트림 처리

스트림: 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임

```
자동차 공장을 생각 해보자.
각각 작업장은 나누어져 있으며 자동차로 구성된 스트림을 처리하는데
각각의 작업장에서는 자동차를 받아서 수리한 다음에, 다음 작업장에서
다른 작업을 처리할 수 있도록 넘겨준다.
조립 라인은 자동차를 물리적인 순서로 한 개씩 운반하지만 각각의 작업장에서는
동시에 작업을 처리한다.
```

Stream<T> : T 형식으로 구성된 일련의 항목

우선은 스트림 API는 조립 라인처럼 어떤 항목을 연속으로 제공하는 어떤 기능이라고 단순하게 생각하자.

`핵심` : 고수준으로 추상화해서 일련의 스트림으로 만들어 처리할 수 있다는 것.

스트림 파이프라인을 이용하면 여러 CPU 코어에 쉽게 할당할 수 있다는 부가적인 이득도 얻음.

공짜로 병렬성을 얻을 수 있다. (쓰레드를 사용하지 않아도)

### 동작 파라미터화로 메서드에 코드 전달하기

요약하자면 `코드 일부를 API로 전달하는 기능` 

자바 8에서는 메서드(우리 코드)를 다른 메서드의 인수로 넘겨주는 기능을 제공

→ `동작 파라미터화` 라고 부른다.

`스트림 API` 는 연산의 동작을 파라미터화할 수 있는 코드를 전달한다는 사상에 기초한다.

### 병렬성과 공유 가변 데이터

위에서 `병렬성`을 공짜로 얻을 수 있다고 얘기했다.

→ 그러나 공짜는 없다. (코드의 동작 방식을 조금 바꿔야함)

`스트림` 메서드로 전달하는 코드는 다른 코드와 동시에 실행하더라도 안전하게 실행될 수 있어야 함.

- 보통 공유된 가변 데이터에 접근하지 않아야 함.
- 이러한 함수를
    - 순수 함수
    - 부작용 없는 함수
    - 상태 없는 함수

`공유되지 않은 가변 데이터` , 메서드, 함수 코드를 다른 메서드로 전달하는 두 가지 기능은 `함수형 프로그래밍` 패러다임의 핵심적인 사항!

## 자바 함수

프로그래밍 언어에서 함수는 `메서드` 특히 정적 메서드와 같은 의미로 사용

`자바 8` 에서는 함수를 새로운 값의 형식으로 추가

→ `병렬 프로그래밍을 활용할 수 있는 스트림`과 연계될 수 있도록 함수를 만들었기 때문

`프로그래밍 언어의 핵심은 값을 바꾸는 것` → 전통적으로 `일급 값` 이라고 부름

전달할 수 없는 구조체 → `이급 시민`  (자바에서는 메서드, 클래스 등)

따라서 `자바 8 설계자들은 이급 시민을 일급 시민으로 바꿀 수 있는 기능을 추가`

→ 런타임때 메서드를 전달한다면 프로그래밍에 유용하게 사용할 수 있기 때문

### 메서드와 람다를 일급 시민으로

`메서드 참조` 예시

```java
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```

→ 이미 `isHidden` 이라는 함수는 준비되어 있으므로 자바 8의 메서드 참조 `::` 를 이용해서 listFiles에 직접 전달 할 수 있다.

### 람다 : 익명 함수

자바 8에서는 메서드를 일급값으로 취급할 뿐 아니라 `람다` 를 포함하여 함수도 값으로 취급할 수 있다.

물론 직접 메서드를 정의할 수도 있지만, 이용할 수 있는 편리한 클래스나 메서드가 없을 때 새로운 람다 문법을 이용하면 더 간결하게 코드를 구현할 수 있다.

- 람다 문법 형식으로 구현된 프로그래밍: `함수를 일급값으로 넘겨주는 프로그램을 구현한다.`

### 코드로 확인해보기

`필터` : 특정 항목을 선택해서 반환하는 동작

```java
public static boolean isGreenApple(Apple apple){
	return GREEN.equals(apple.getColor);
}

public static boolean isHeavyApple(Apple apple){
		return apple.getWeight() > 150;
}

static List<Apple> filterApples(List<Apple> apples, 
																Predicate<Apple> p) {
	List<Apple> result = new ArrayList<>();
	for(Apple apple: apples){
		if(p.test(apple)){
			result.add(apple);
		}
	}
	return result;
}

// 호출 예
filterApples(apples, Apple::isGreenApple);
```

### 메서드 전달에서 람다로

😅 메서드를 값으로 전달하는 것은 분명 유용하지만 → isHeavyApple, isGreenApple처럼 매번 한 두번 사용할 메서드를 정의하는 것은 귀찮은 일이다.

→ 간단한 해결방법 `람다` 를 사용하자.

```java
filterApples(apples, (Apple a) -> GRREN.equals(a.getColor()));
```

즉, 한 번만 사용할 메서드는 따로 정의를 구현할 필요가 없다.

`하지만` 람다가 몇 줄 이상으로 길어진다면(즉, 조금 복잡한 행동을 수행할 때)

→ 익명 람다보다는 코드가 수행하는 일을 잘 설명하는 이름을 가진 메서드를 정의하고 메서드 참조를 활용하는 것이 바람직 (코드의 명확성이 우선시되어야 함)

**`컬렉션과 스트림 간에 변환할 수 있는 메서드 (map, reduce 등) 도 제공한다.`**


Reference:  
[모던자바인액션](http://www.yes24.com/Product/Goods/77125987)