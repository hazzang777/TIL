# 함께 모으기

## 😎 INTRO

<aside>
💡 코드와 모델을 밀접하게 연관시키는 것은 코드에 의미를 부여하고 모델을 적절하게 한다.
 - 에릭 에반스

</aside>

객체지향 설계 안에 존재하는 세 가지 관점이 있다.

1. 개념 관점
    1. 도메인 안에 존재하는 개념과 개념들 사이의 관계
    2. 사용자가 도메인을 바라보는 관점
    3. `클래스가 은유하는 개념`
2. 명세 관점
    1. 사용자의 영역인 도메인을 벗어나 개발자의 영역인 소프트웨어로 초점이 옮겨짐
    2. 객체가 협력을 위해 `무엇` 을 할 수 있는가에 초점을 맞춤
    3. 명세 관점과 구현 관점을 명확하게 분리하는 것은 중요
    4. `공용 인터페이스`
3. 구현 관점
    1. 실제 작업을 수행하는 코드와 연관
    2. 프로그래머는 객체의 책임을 `어떻게` 수행할 것인가에 초점을 맞춤
    3. 인터페이스를 구현하는 데 필요한 속성과 메서드를 클래스에 추가
    4. `속성과 메서드`

→ 이 세 가지 관점들은 동일한 클래스를 각 관점에서 다른 방향으로 보는 것이다.

→ 클래스는 세 가지 관점을 모두 수용할 수 있도록 개념, 인터페이스, 구현을 함께 드러내야함

## ☕️ 커피 전문점 도메인

### 커피 주문

```
커피 전문점에서는 아메리카노, 카푸치노, 카라멜 마끼아또, 에스프레소 네 가지 커피를 판매
커피의 이름과 가격이 적힌 메뉴판이 비치돼 있다.
```

### 🚩 커피 전문점이라는 세상

객체지향 패러다임의 가장 중요한 도구는 객체!

→ 커피 전문점들을 객체들로 구성된 작은 세상으로 바라보자.

- 메뉴판은 하나의 객체
- 메뉴 항목은 총 4개로 구성 각각 역시 객체로 볼 수 있음
- 손님 역시 객체
- 커피를 제조하는 바리스타는 객체
- 바리스타가 제조하는 커피 역시 객체

→ 손님, 메뉴판, 메뉴 항목, 바리스타, 커피 모두 객체!

- 객체들의 관계
    - 손님과 바리스타 사이의 관계 존재 (손님은 바리스타에게 주문한다.)
    - 손님과 메뉴판 사이의 관계 존재 (손님은 메뉴판을 보고 주문을 한다.)
    - 바리스타와 커피 사이의 관계 존재 (바리스타는 커피를 제조하는 사람)
    - 메뉴판과 메뉴 항목 사이의 관계 존재 (메뉴판과 메뉴 항목 객체는 하나의 단위로 움직임)
        - 메뉴 항목 객체는 메뉴판 객체에 포함돼 있다.
    
    <aside>
    💡 메뉴판과 메뉴 항목과 같은 사이의 관계는 `포함` 
    메뉴판 타입은 손님의 일부가 아니므로 이 관계는 `연관`
    
    </aside>
    
    → 소프트웨어가 대상으로 하는 영역인 도메인을 단순화해서 표현한 모델을 `도메인 모델` 
    

![Untitled](https://user-images.githubusercontent.com/68279162/170869413-5e3682d8-92b2-42e4-af49-4f94c0f39ed0.png)

 → 커피 전문점을 구성하는 타입들

<aside>
💡 도메인 모델을 작성하는 단계에서 초점은 어떤 타입이 도메인을 구성하느냐와 타입들 사이에 어떤 관계가 존재하는지를 파악함으로써 도메인을 이해하는 것이다.

</aside>

## 😀 설계하고 구현하기

### ☺️ 커피를 주문하기 위한 협력 찾기

객체지향의 첫 번째 목표는 휼륭한 협력을 설계하는 것

→ 메시지를 먼저 결정한 후 적합한 객체를 선택하는 것

![Untitled 1](https://user-images.githubusercontent.com/68279162/170869415-3eba62cd-be15-45df-a15a-f3640ab42e0c.png)


→ 커피 주문을 위한 객체 협력

1. 적절한 타입을 발견했다면 책임을 수행할 객체를 그 타입의 인스턴스로 만들자
    1. 소프트웨어 객체에게 현실 객체와 유사한 이름을 붙여 놓으면 유사성을 통해 소프트웨어 객체가 수행해야 하는 책임과 상태를 좀 더 쉽게 유추 할 수 있다.

- FLOW
    - 손님 객체는 `커피를 주문하라` 라는 책임을 할당 받았다.
        - 손님이 할당된 책임을 수행하는 도중에 스스로 할 수 없는 일이 있다.
        - 다른 객체에게 이를 요청해야 함
    - 메뉴 항목은 메뉴판의 일부라는 사실
        - 손님은 주문을 하기 위해 `메뉴 항목을 찾아라` 라는 요청을 해야한다.
        - 이 책임을 누구에게 할당하는 것이 좋을까?
            - 메뉴판 객체는 메뉴 항목 객체를 포함하기 때문에 이 책임을 처리할 적절한 후보이다.
    - 손님은 메뉴 항목을 얻었으니 `커피를 제조`해달라고 요청을 해야함
        - 손님은 메뉴 항목을 메시지의 인자로 함께 전달하고 반환값으로 제조된 커피를 받아야 함
    - 바리스타는 스스로의 판단과 지식에 따라 행동하는 자율적인 존재
        - 바리스타가 새로운 커피를 만듬으로 인해 커피 주문의 협력은 끝이나게 된다.

 → 이로서 협력에 필요한 객체의 종류와 책임, 주고받아야 하는 메시지에 대한 윤곽이 드러남

 → 메시지를 정제함으로써 각 객체의 인터페이스를 구현 가능할 정도로 상세하게 정제 해야함

<aside>
💡 객체지향 세계에서는 모든 객체가 능동적이고 자율적인 존재
메뉴판은 마치 생명을 가진 존재처럼 자기 스스로 메뉴 항복을 찾음
소프트웨어 객체는 현실 속의 객체를 모방하거나 추상화한 것이 아니라
단지 유추하기 쉽도록 `은유` 한 것

</aside>

 

### 😆 인터페이스 정리하기

<aside>
💡 메시지가 객체를 선택했고, 선택된 객체는 메시지를 자신의 인터페이스로 받아들인다.

</aside>

인터페이스에 포함된 오퍼레이션 역시 외부에서 접근 가능하도록 `공용(public)`으로 선언해야함.

```java
class Customer{
	public void order(String menuName){}
}

class MenuItem {
}

class Menu {
	public MenuItem choose(String name) {}
}

class Barista {
	public Coffee makeCoffee(MenuItem menuItem) {}
}

class Coffee {
	public Coffee(MenuItem menuItem) {}
}
```

### 🧱 구현하기

클래스의 인터페이스로 식별 했다.

이제 오퍼레이션을 수행하는 메서드로 구현할 차례!

1. `손님`은 `메뉴판`에게 메뉴 항목 이름에 해당하는 `메뉴 항목`을 요청
2. `메뉴 항목`을 받아 `바리스타`에게 원하는 `커피`를 제조하도록 요청

<aside>
💡 여기서 다른 객체에게 메시지를 전송하기 위해서는 다른 객체의 참조를 얻어야 함

</aside>

→ 객체 참조를 얻는 다양한 방법이 있다.

→ 여기서는 `order()` 메서드의 인자로 `메뉴`와 `바리스타` 객체를 전달받는 방법으로 해결

```java
class Customer {
	public void order(String menuName, Menu menu, Barista barista) {}
}

// order 메서드 구현 해보자.
class Customer {
	public void order(String menuName, Menu menu, Barista barista) {
		MenuItem menuItem = menu.choose(menuName);
		Coffee coffee = barista.makeCoffee(menuItem);
		...
	}
}
```

<aside>
💡 구현 도중에 객체의 인터페이스가 변경될 수 있다는 점을 주목해라

</aside>

<aside>
💡 구현하지 않고 머릿속으로만 구상한 설계는 코드로 구현하는 단계에서 대부분 변경됨.
설계 작업은 구현을 위한 스케치를 작성하는 단계지 구현 그 자체일 수는 없다.
따라서 협력을 구상하는 단계에 너무 시간을 쏟지 말고 최대한 빨리 코드를 구현해서 설계에 이상이 없는지, 설계가 구현 가능한지를 판단해야 함

</aside>

- 메뉴판
    - `메뉴`는 메뉴 이름을 통해 `메뉴 항목`을 찾아야 하는 책임이 있다.
    - `메뉴`는 `메뉴 항목`을 내부에서 관리하고 있어야 한다.

```java
class Menu {
	private List<MenuItem> items;
	
	public Menu(List<MenuItem> items){
		this.items = items;
	}

	public MenuItem choose(String menuName){
		for(MenuItem each : items) {
			if(each.getName().equals(menuName)){
				return each;
			}
		}
		return null;
	}
}
```

<aside>
💡 객체에게 책임을 할당하고 인터페이스를 결정할 때는 가급적 객체 내부의 구현에 대한 어떤 가정도 하면 안된다. 객체가 어떤 책임을 수행해야 하는지를 결정한 후에야 책임을 수행하는 데 필요한 객체의 속성을 결정하라. 이것이 객체의 구현 세부 사항을 객체의 공용 인터페이스에 노출시키지 않고 인터페이스와 구현을 깔끔하게 분리할 수 있는 기본적인 방법

</aside>

- `바리스타`는 `메뉴 항목`을 이용해서 `커피`를 제조한다.

```java
class Barista {
	public Coffee makeCoffee(MenuItem menuItem){
		Coffee coffee = new Coffee(menuItem);
		return coffee;
	}
}
```

- `커피`는 자기 자신을 생성하기 위한 생성자를 제공한다.
    - `커피`는 커피 이름과 가격을 속성으로 가진다.
    - 생성자 안에서 `메뉴 항목`에 요청을 보내 커피 이름과 가격을 얻은 후 커피를 생성

```java
class Coffee {
	private String name;
	private int price;

	public Coffee(MenuItem menuItem){
		this.name = menuItem.getName();
		this.price = menuItem.cost();
	}
}
```

- 메뉴 항목은 getName()과 cost() 메시지에 응답할 수 있도록 메서드를 구현해야 함.

```java
public class MenuItem{
	private String name;
	private int price

	public MenuItem(String name, int price){
		this.name = name;
		this.price = price;
	}

	public int cost() {
		return price;
	}

	public String getName() {
		return name;
	}
}
```

<aside>
💡 인터페이스는 객체가 다른 객체와 직접적으로 상호작용하는 통로
인터페이스를 통해 실제로 상호작용을 해보지 않은 채 인터페이스의 모습을 정확하게 예측하는 것은 불가능
설계를 간단히 끝내고 최대한 빨리 구현해라
설계가 제대로 안그려진다면 실제로 코드를 작성해가면서 협력의 전체적인 밑그림을 그려보라
이것이 테스트-주도 설계이다.

</aside>

## 🍀 코드와 세 가지 관점

### 코드는 세 가지 관점을 모두 제공해야 한다.

- 개념 관점
    - 코드를 바라보면 Customer, Menu, MenuItem, Barista, Coffee 클래스가 보임
    - 이 클래스들을 보면 도메인을 구성하는 개념과 관계를 반영한다는 것을 알 수 있다.
    - 소프트웨어 클래스가 도메인 개념의 특성을 최대한 수용한다면
        - 변경을 관리하기 쉽다.
        - 유지보수성을 향상
- 명세 관점
    - 클래스의 인터페이스를 바라봄
    - 클래스의 public 메서드는 다른 클래스가 협력할 수 있는 공용 인터페이스를 드러낸다.
    - 인터페이스를 수정하면 해당 객체와 협력하는 모든 객체에게 영향을 미침
    - 최대한 변화에 안정적인 인터페이스를 만들기 위해서는
        - `구현과 관련된 세부 사항이 드러나지 않게 해야함`
- 구현 관점
    - 클래스의 내부 구현을 바라봄
    - 클래스의 `메서드`와 `속성`은 공용 인터페이스의 일부가 아님
        - 철저하게 클래스 내부로 `캡슐화`돼야 한다는 것을 의미

<aside>
💡 개념 관점, 명세 관점, 구현 관점은 동일한 코드를 바라보는 서로 다른 관점

</aside>

### 😎 도메인 개념을 참조하는 이유

<aside>
💡 어떤 메시지가 있을 때 그 메시지를 수신할 객체를 어떻게 선택하는가?

</aside>

1. 도메인 개념 중에서 가장 적절한 것을 선택하는 것
    - 도메인 개념 안에서 적절한 객체를 선택하는 것은 이미 도메인에 대한 지식을 기반으로 쉽게 유추가 가능하다.

😅 소프트웨어는 항상 변한다.

→ 소프트웨어 클래스가 도메인 개념을 따르면 변화에 쉽게 대응 가능

→ 클래스 안에서 인터페이스와 구현을 분리하는 이유

### 🙌🏻 인터페이스와 구현을 분리하라

<aside>
💡 인터페이스와 구현을 분리하라

</aside>

- 인터페이스가 구현 세부 사항을 노출하기 시작하면 아주 작은 변동에도 전체 협력에 영향이 가게 된다.
- 명세 관점에서는 구현 관점을 분리하는 것은 매우 중요하다고 주장 [Fowler]
- 실제로 휼륭한 설계를 결정하는 측면은 명세 관점인 객체의 인터페이스다.
- 중요한 것은 여러분이 클래스를 봤을 때 `명세 관점`과 `구현 관점`으로 나눠 볼 수 있어야 한다.
    - 인터페이스와 구현을 분리하라는 뜻

Reference : 
 [객체지향의 사실과 오해](http://www.yes24.com/Product/Goods/18249021)    